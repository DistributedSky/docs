# Drone Employee Connect

## application.py

Файл огранизует необходимое приложение, используя микрофреймворк Flask, с помощью которого создаются веб-приложения.

```python
from flask import Flask
```

Далее создается объект приложения (наследуя Flask) с соответствующим именем. Также указывается путь для статических файлов: `/static`. Этот объект выступает в качестве центрального реестра для функций просмотра, правил URL, конфигурации шаблона и многого другого.

```python
app = Flask(__name__, static_url_path='/static')
```
Далее используется декоратор `route()`, который регистрирует за определенным URL предложенную функцию. В нашем случае описываются два метода:

* `index()`: отвечает за направление пользователя на главную страницу;

* `static_file(path)`: отвечает за направление пользователя на каталог, содержащийся в переменной `path`.

## wifi.py

Файл связывает беспроводные адаптеры с контейнерами Docker, используя API для работы с Docker и модуль `system` формирования системных bash-запросов.

```python
from os import system as system_call
from docker import from_env
```

Файл содержит в себе следующий метод:

```python
def spawn(name, wlan, ssid, password):
  ...
```

Этот метод переподключает беспроводной адаптер в контейнер Docker, используя стандартные данные:

* `name` – имя контейнера;
* `wlan` – имя интерфейса WLAN с порядковым номером;
* `ssid` – имя беспроводной сети;
* `password` – пароль от беспроводной сети.

Ниже описан алгоритм по перенаправлению ранее сохраненных адаптеров для актуальных контейнеров:

```python
if __name__ == '__main__':
    links = [x[:-1].split(',') for x in open('/etc/dronelinks.csv', 'r')]

    for name, wlan, ssid, password in links:
        try:
            spawn(name, wlan, ssid, password)
        except:
            print('broken ' + name)
```

*Примечание.* Задержка `time.sleep(30)` необходима для ожидания загрузки актуальных контейнеров Docker.

## resources.py

Рассмотрим библиотеки, которые используются в этом файле:

```python
from flask_restful import Resource, Api, reqparse
from platform import machine, processor, system
from os import system as system_call
from netifaces import interfaces
from docker import from_env
from application import app
import psutil, time, json, wifi
```

Видно, что подгружаются вышеупомянутые модуль `wifi` и веб-интерфейса `app`. Файл использует расширение для Flask – Flask-RESTful: наборы методов по работе с экземпляром класса Flask. Используется библиотека `platform`, которая собирает весь доступный массив информации о аппаратной части платформы. Библиотека `netifaces` необходима для работы с портативными сетевыми интерфейсами. Также подгружается модуль Docker `from_env`, который необходим для связи с Docker Daemon с помощью конфигурации переменных окружения.

В этом модуле опеределны три класса:

* Класс `Containers(Resource)`

  В конструкторе класса инициализируется атрибут `parcer`, который представляет собой RESTful API запрос с дополнительными аргументами – образ и параметры.

  Теперь рассмотри методы класса `Containers`.

  1. Метод `get()`

    Метод возвращает список имен актуальных контейнеров.

  2. Метод `post()`

    Метод предназначен для регламентых операций по корректной интеграции контейнеров в схему работы продукта.

* Класс `Container(Resource)`

    В конструкторе класса инициализируется атрибут `parcer`, который представляет собой RESTful API запрос с дополнительным аргументом – `cmd`.

    Теперь рассмотри методы класса `Container`.

    1. Метод `get()`

    Метод возвращает список значений из текущего контейнера в формате:

    ```python
    {'containers': {
                    name: {
                        'status': c.status,
                        'image': c.attrs['Config']['Image']
                        }}}
    ```

    2. Метод `delete(name)`

    Вспмомогательный метод по удалению контейнера из функциональной схемы продукты.

    3. Метод `post(name)`

    Метод предназначен для регламентых операций по корректной интеграции контейнера в схему работы продукта: метод используется для взаимодействия с веб-интерфейсом. Он выполняет ряд команд: команда по предоставлению информации о логировании внутри этого контейнера и команда о перезапуске контейнера.

* Класс `Hardware(Resource)`

  Данный класс содержит едиственный метод `get()` преднозначенный для получения информации о текущем состоянии hardware текущий платформы.

В процессе инициализации данного набора классов и методов производится добавление дополнительных методов взаимодействия с веб-сервером, а именно:

```python
api = Api(app)
api.add_resource(Containers, API_PREFIX+'/containers')
api.add_resource(Container,  API_PREFIX+'/containers/<name>')
api.add_resource(Hardware,   API_PREFIX+'/hardware')
```

*Примечание.* Необходимо уточнить, что из себя представляет атрибут `parcer` в конструкторе класса `Containers`.

## serve.py

Описанные ранее модули `application` и `resources` объединяются в модуле *serve.py*. Этот модуль является точкой запуска всех методов, классов, сервисов и приложений для функционирования Ground station administrative tool stack.
